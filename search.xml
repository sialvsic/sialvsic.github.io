<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[将docker镜像部署到AWS并运行]]></title>
      <url>http://yoursite.com/2016/11/17/docker-aws/</url>
      <content type="html"><![CDATA[<h1>如何将docker镜像部署到AWS上并运行</h1>
<p><code>workflow</code></p>
<p>1.利用sinatra启动本地的web server提供web服务</p>
<p>2.安装docker服务</p>
<p>3.将sinatra提供的websever安装到docker中</p>
<p>4.本地设置端口映射调试</p>
<p>5.注册AWS，部署docker镜像并运行</p>
<hr>
<h2>step1 利用sinatra启动本地的webserver提供web服务</h2>
<blockquote>
<p>sinatra 的官网为：http://www.sinatrarb.com/</p>
</blockquote>
<blockquote>
<p>sinatra 的github网址为：https://github.com/sinatra/sinatra</p>
</blockquote>
<p>文档很详细，启动一个web 的服务只需要：</p>
<p>新建一个ruby的文件，命名为myapp.rb，代码如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># myapp.rb</div><div class="line">require &apos;sinatra&apos;</div><div class="line"></div><div class="line">get &apos;/&apos; do</div><div class="line">  &apos;Hello world!&apos;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>Install the gem:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install sinatra</div></pre></td></tr></table></figure></p>
<p>And run with:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby myapp.rb</div></pre></td></tr></table></figure></p>
<p>View at: http://localhost:4567 (默认的端口，可以更改)即可，会看到页面上出现<code>Hello world!</code></p>
<p>Note: sinatra会提供路由的处理，本例只是一个最最简单的get方法的路由访问；
如果没有ruby和gem的命令，请参见google先安装ruby；</p>
<h2>step2 安装docker</h2>
<p>本机使用osx系统，所以打开docker官网 https://docs.docker.com/docker-for-mac/  直接下载dmg文件安装即可，安装详情请参考此文档 https://docs.docker.com/docker-for-mac/#/step-1-install-and-run-docker-for-mac</p>
<h2>step3 将sinatra提供的websever安装到docker中</h2>
<p>思路：如何实现这步，首先我们需要建立一个Dockerfile，用于将执行的命令写入；之后需要新建一个docker image即可.</p>
<p>a.新建一个Dockerfile文件
内容如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># This is a comment</div><div class="line">FROM ubuntu:14.04</div><div class="line">MAINTAINER sialvsic &lt;sialvsic@outlook.com&gt;</div><div class="line">RUN mkdir /run-docker</div><div class="line">WORKDIR /run-docker</div><div class="line">RUN apt-get update &amp;&amp; apt-get install -y ruby</div><div class="line">RUN gem install bundler</div><div class="line">COPY main.rb main.rb</div><div class="line">COPY Gemfile Gemfile</div><div class="line">COPY config.ru config.ru</div><div class="line">RUN bundle install</div><div class="line">EXPOSE 8081</div><div class="line">CMD rackup --host 0.0.0.0 -p 8081</div><div class="line"># CMD [&quot;bundle&quot;, &quot;exec&quot;, &quot;rackup&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;-p&quot;, &quot;8081&quot;]</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>#</code> 注释</p>
</blockquote>
<blockquote>
<p>EXPOSE 表示显示的声明要导出的端口号</p>
</blockquote>
<blockquote>
<p>CMD 表示build时不运行，但是在容器执行时运行的命令</p>
</blockquote>
<p>新建好Dockerfile之后，执行命令
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t star:1.0 .</div></pre></td></tr></table></figure></p>
<p>-t 表示；</p>
<p>. 表示当前路径；</p>
<p>执行docker images 命令会看到存在一个REPOSITORY 为star TAG为1.0的一条新的镜像，此时镜像已经build成功</p>
<h2>step4 设置本地端口映射</h2>
<p>我们清楚，docker 是运行在一个虚拟机中的，本质上也是一个小型的精简的linux系统，所以docker的镜像运行时只会在linux系统中打开一个8081端口，但是在当前的osx的系统中是没有办法访问的，所以需要配置端口映射，如何配置：仅需要在docker的镜像运行时指定-p参数，eg:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 7080:8081 star:1.0</div></pre></td></tr></table></figure></p>
<p>-d表示后台运行，7080代表hostport,8081代表docker内部的port号，
此时打开浏览器输入： localhost:7080 即可访问</p>
<h2>step5 注册AWS，部署docker镜像并运行</h2>
<p>注册很简单，唯一注意的就是需要绑定信用卡</p>
<p>如何部署，Follow以下文档
https://aws.amazon.com/cn/getting-started/tutorials/deploy-docker-containers/</p>
<h2>常见技巧</h2>
<h3>删除所有的docker containers</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $(docker ps -a -q)</div></pre></td></tr></table></figure></p>
<h3>删除所有的docker images</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi $(docker images -q)</div></pre></td></tr></table></figure></p>
<h2>常见问题</h2>
<h3>无法删除镜像</h3>
<p>场景：使用docker rmi 命令时出现以下提示
Error response from daemon: Conflict, cannot delete 91c95931e552 because the container 76068d66b290 is using it, use -f to force FATA[0000] Error: failed to remove one or more images</p>
<p>分析：因为镜像正在运行或者镜像间存在依赖</p>
<p>解决：加上-f 参数强制删除</p>
<h3>Don't run Bundler···</h3>
<p>场景: docker build 时出现以下的提示
Don't run Bundler as root. Bundler can ask for sudo if it is needed, and
installing your bundle as root will break this application for all non-root
users on this machine.</p>
<p>分析：是一个错误警告，但不是一个错误，暂时还没有解决</p>
<p>解决：</p>
<h3>Could not locate Gemfile or .bundle/ directory</h3>
<p>场景：运行docker build报错</p>
<p>分析：在书写Dockerfile的过程中，需要考虑到自己写的文件的位置，牵扯到运行问题。docker 提供COPY和ADD可以用于拷贝文件到docker虚拟机，但是存在docker的运行解析问题，可能会找不到文件</p>
<p>解决：使用 WORKDIR处理好</p>
<h3>已经配置好了端口映射但是本地仍然无法访问</h3>
<p>场景：已经建立好了镜像，在运行镜像时尝试执行了以下命令均无效果
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -d -p localhost:7080:8081 star:1.0</div><div class="line">docker run -d -p 7080:8081 star:1.0</div><div class="line">docker run -d -p 127.0.0.1:7080:8081 star:1.0</div></pre></td></tr></table></figure></p>
<p>分析：看了文档觉得这些都是对的，一开始就很奇怪这样子为什么不对，早上无意间看了一下别人的问题试了一下解决了，但是还不是很清楚为什么加了这个参数就可以了。</p>
<p>解决：在Dockerfile的web运行时加入参数 --host 0.0.0.0</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mysql install uninstall and simple use]]></title>
      <url>http://yoursite.com/2016/08/28/mysql/</url>
      <content type="html"><![CDATA[<h1>Mysql install uninstall and simple use</h1>
<hr>
<h2>MAC下安装</h2>
<h3>推荐使用homebrew安装</h3>
<p>执行下列安装命令</p>
<p>更新brew
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew  update</div></pre></td></tr></table></figure></p>
<p>安装mysql
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install mysql</div></pre></td></tr></table></figure></p>
<p>安装完之后会出现提示：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">We&apos;ve installed your MySQL database without a root password. To secure it run: `mysql_secure_installation`</div><div class="line">To connect run: `mysql -u root` To have launchd start mysql at login:</div><div class="line">ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents</div><div class="line">Then to load mysql now:</div><div class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</div><div class="line">Or, if you don&apos;t want/need launchctl, you can just run:</div><div class="line"></div><div class="line">mysql.server start</div></pre></td></tr></table></figure></p>
<p><code>此处仅为了解即可，建议不要执行以下该命令</code>
然后执行<strong>mysql_secure_installation</strong> 会出现</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&gt; Securing the MySQL server deployment.</div><div class="line">&gt;</div><div class="line">Connecting to MySQL using a blank password.</div><div class="line">&gt;</div><div class="line">VALIDATE PASSWORD PLUGIN can be used to test passwords</div><div class="line">and improve security. It checks the strength of password</div><div class="line">and allows the users to set only those passwords which are</div><div class="line">secure enough. Would you like to setup VALIDATE PASSWORD plugin?</div><div class="line">&gt;</div><div class="line">Press y|Y for Yes, any other key for No: No</div><div class="line">Please set the password for root here.</div><div class="line">&gt;</div><div class="line">New password:  Vaystar@0917</div><div class="line">&gt;</div><div class="line">Re-enter new password:</div><div class="line">By default, a MySQL installation has an anonymous user,</div><div class="line">allowing anyone to log into MySQL without having to have</div><div class="line">a user account created for them. This is intended only for</div><div class="line">testing, and to make the installation go a bit smoother.</div><div class="line">You should remove them before moving into a production</div><div class="line">environment.</div><div class="line">&gt;</div><div class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</div><div class="line">Success.</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">Normally, root should only be allowed to connect from</div><div class="line">&apos;localhost&apos;. This ensures that someone cannot guess at</div><div class="line">the root password from the network.</div><div class="line">&gt;</div><div class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : N</div><div class="line"> ... skipping.</div><div class="line">By default, MySQL comes with a database named &apos;test&apos; that</div><div class="line">anyone can access. This is also intended only for testing,</div><div class="line">and should be removed before moving into a production</div><div class="line">environment.</div><div class="line">&gt;</div><div class="line">&gt;</div><div class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y</div><div class="line"> -Dropping test database...</div><div class="line">Success.</div><div class="line">&gt;</div><div class="line"> -Removing privileges on test database...</div><div class="line">Success.</div><div class="line">&gt;</div><div class="line">Reloading the privilege tables will ensure that all changes</div><div class="line">made so far will take effect immediately.</div><div class="line">&gt;</div><div class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</div><div class="line">Success.</div><div class="line">&gt;</div><div class="line">All done!</div><div class="line"></div><div class="line">到此安装完毕，使用时输入mysql -u root -p 的命令即可，输入密码</div><div class="line">我的密码为:  安装于`2016.8.26`</div><div class="line"></div><div class="line">Vaystar@0917</div></pre></td></tr></table></figure></p>
<h3>出现的问题</h3>
<h4>CLI下输入MySQL command not found</h4>
<p>问题分析：环境变量设置不对
解决方法：
在.zshrc 中写入，之后source一下即可。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=$PATH:/usr/local/mysql/bin</div></pre></td></tr></table></figure></p>
<h3>自己尝试的错误</h3>
<p>开始在官网上下载dmg 的安装包，正常安装后出现下列问题
http://stackoverflow.com/questions/33326065/unable-to-access-mysql-after-it-automatically-generated-a-temporary-password
mysql会自动的生成一个random password，但你在使用<strong>mysql -u root -p</strong> 后输入该随机的密码时又会出错，在网上找了各种方法无果。
所以，</p>
<blockquote>
<p>mac下安装不推荐使用dmg安装</p>
</blockquote>
<p>遂之后使用  brew install mysql 安装，开始有些冲突，最后莫名其妙的好了，也是醉了。</p>
<h2>MAC下卸载</h2>
<p>1.关闭mysql服务</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql.server stop</div></pre></td></tr></table></figure></p>
<p>2.依次执行以下命令</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sudo rm /usr/local/mysql   </div><div class="line">sudo rm -rf /usr/local/mysql*</div><div class="line">sudo rm -rf /Library/StartupItems/MySQLCOM</div><div class="line">sudo rm -rf /Library/PreferencePanes/My*</div><div class="line">rm -rf ~/Library/PreferencePanes/My*</div><div class="line">sudo rm -rf /Library/Receipts/mysql*</div><div class="line">sudo rm -rf /Library/Receipts/MySQL*</div><div class="line">sudo rm -rf /private/var/db/receipts/*mysql*</div><div class="line">sudo rm -rf /var/db/receipts/com.mysql.</div><div class="line">调用vim /etc/hostconfig，删除 MYSQLCOM=-YES-这一行。</div></pre></td></tr></table></figure></p>
<p>3.在根目录下执行以下命令 查找依旧存在的mysql  并删除 千万别乱删，容易出事
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . mysql | grep mysql</div></pre></td></tr></table></figure></p>
<p>可以删除</p>
<ul>
<li>/usr/local/var/mysql  整个文件</li>
<li>/usr/local/share/mysql</li>
<li>/usr/local/Cellar/mysql  整个文件</li>
</ul>
<p><code>Note:</code> 可能会发现以上的命令在执行时根本不存在或者没有该文件，是因为mysql 的版本不同导致。</p>
<p>参考链接</p>
<p>1.stackoverflow：http://stackoverflow.com/questions/1436425/how-do-you-uninstall-mysql-from-mac-os-x</p>
<p>2.http://www.jb51.net/article/81447.htm</p>
<p>日志：
2016.8.28</p>
<p>使用brew install mysql  ，但是手贱执行mysql_secure_installation，并设置了中级难度的root密码，结果发现在跑黑工项目时，默认的root密码是空，我就GG了，其实改一下项目的配置文件就好了，但是强迫症 + 完美主义患者是不喜欢凑合的，所以研究了一下如何卸载重装mysql</p>
<h2>How to start run and stop</h2>
<p>Usage: mysql.server  {start|stop|restart|reload|force-reload|status}  [ MySQL server options ]</p>
<blockquote>
<p>mysql.server start</p>
</blockquote>
<blockquote>
<p>mysql.server stop</p>
</blockquote>
<blockquote>
<p>mysql.server restart</p>
</blockquote>
<blockquote>
<p>mysql.server status</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 基础]]></title>
      <url>http://yoursite.com/2016/08/23/java-basic/</url>
      <content type="html"><![CDATA[<h1>Java Basic</h1>
<hr>
<h2>what is java?</h2>
<p>Java 编程语言是个简单、完全面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的编程语言，Java可以撰写跨平台应用软件</p>
<ul>
<li>java EE</li>
<li>java ME</li>
<li>java SE</li>
</ul>
<h2>why use java?</h2>
<ul>
<li>面向对象的设计思想</li>
<li>垃圾自动回收机制</li>
</ul>
<h2>when to use java?</h2>
<h2>where to use java?</h2>
<h2>who create java?</h2>
<h2>how to use java?</h2>
<h2>java 的工作方式</h2>
<p>1.源代码  -&gt;  2.编译器  -&gt;  3.输出 -&gt; 4.java 虚拟机</p>
<ol>
<li>编写源码文件</li>
<li>用编译器运行源代码同时检查错误，如果存在错误就会报错</li>
<li>编译器会产生字节码。 字节码与平台无关</li>
<li>通过java 的虚拟机可以运行字节码</li>
</ol>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">编译器可以使用javac命令</div><div class="line">虚拟机可以使用java命令</div></pre></td></tr></table></figure></p>
<h2>java history</h2>
<ul>
<li>java 1.02</li>
<li>java 1.1</li>
<li>java 2 version 1.2 ~ 1.4</li>
<li>java 5 version 1.5</li>
</ul>
<p>tip：因为销售人员所以没有java 3 或4</p>
<h2>核心概念</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JDK   (java Development Kit)          java 软件开发包</div><div class="line">JRE   (java Runtime Envirment)</div><div class="line">JVM  (java virtual machine)</div><div class="line"></div><div class="line">JDK 包含 JRE 包含 JVM</div></pre></td></tr></table></figure></p>
<h2>基础代码</h2>
<p>main 函数</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//MyfirstApp.java</div><div class="line">public class MyfirstApp &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;hello world!!&quot;);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>过程：</p>
<p>1.先使用javac 命令，生成一个MyfirstApp.class的字节码文件</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac MyfirstApp.java</div></pre></td></tr></table></figure></p>
<p>2.使用java命令，<code>此处不需要指定后缀</code> 此命令执行的是含有main函数的class</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java MyfirstApp</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>文件名应该和类名一样</li>
<li>每个语句必须有；号</li>
<li>字符串使用双引号</li>
<li>while()  括号中不能为int 型   只能为boolean类型  可以写成 while(x==4)</li>
<li>main函数可以出现任意一个名字的类中，但是只能有一个main函数</li>
<li>java 是一种强类型语言，所以特别要注意数据类型</li>
</ul>
<h2>面向对象</h2>
<h3>优势</h3>
<ul>
<li>使用自然的方法设计</li>
<li>加入新功能时不会影响已有的代码</li>
<li>类可以复用</li>
</ul>
<p>面向对象的设计
思想：专注于程序中出现的事物而不是过程。</p>
<h2>类和对象</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">类</div><div class="line">类是对象的蓝图</div><div class="line"></div><div class="line">对象</div><div class="line">对象本身已知的事物被称为： 实例变量（状态）</div><div class="line">对象可以实行的动作被称为：方法（行为）</div></pre></td></tr></table></figure></p>
<h2>面向对象的特性</h2>
<h3>继承</h3>
<p>覆盖 override</p>
<blockquote>
<p>什么时候用继承？
判断 Is-A 的关系
Note： Is-A的关系是一个单向先下的关系！</p>
</blockquote>
<p>合理的继承设计是可以通过 Is-A 的层级检测的</p>
<p>如果在子类中打算引用父类的方法，然后再加上额外的行为时，可以按照如下的方式</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pulic void run()&#123;</div><div class="line">    super.run();</div><div class="line">    // add your special action</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>当你定义出一组类的父型时，你可以用子类型的任何类来填补任何需要或期待的父型位置</p>
</blockquote>
<h3>多态</h3>
<p>运用多态时，引用类型可以是实际对象类型的父型
eg：
有一个Dog 类和 Animal类，Dog类是Animal 的子类，在新建对象时可以这么建立</p>
<pre><code>Animal dog = new Dog(); 
</code></pre>
<p>多态可以运用在参数多态和返回值多态，详见P187页（head first java）</p>
<h4>覆盖 (override)</h4>
<p>覆盖的要求：</p>
<ul>
<li>参数一样，返回类型兼容</li>
<li>不能降低方法的存储权限</li>
</ul>
<h4>重载（overload）</h4>
<p>重载是两个方法的方法名字相同，但参数不同</p>
<blockquote>
<p>重载与多态无关</p>
</blockquote>
<p>重载的要求</p>
<ul>
<li>返回类型不同</li>
<li>不能只改变返回类型</li>
<li>可以更改存取权限</li>
</ul>
<h3>封装</h3>
<h2>存储权限</h2>
<h2>语法</h2>
<h3>数组定义</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String [] arr = &#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;;</div><div class="line">int [] nums = new int[7];</div><div class="line">Dog [] pets = new Dog[7];</div></pre></td></tr></table></figure></p>
<p>虽然元素本身是primitive主数据类型，但是<code>数组却是一个对象</code></p>
<h3>final 标识符</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final标志符用于标识为一个继承树的末端，不能被继承</div><div class="line">final 标志整个类说明整个类的方法都不能被继承</div><div class="line">final 标志一个方法说明这个方法不能被覆盖</div></pre></td></tr></table></figure></p>
<h3>abstract 标志符</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">abstract 标志符用于说明抽象的事物</div><div class="line">abstract 标志整个类说明该类是一个抽象类</div><div class="line">abstract 标志一个方法说明一个方法是一个抽象方法，该方法一定是要被覆盖的</div></pre></td></tr></table></figure></p>
<h2>变量</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">变量定义规则：</div><div class="line">rule 1：</div><div class="line">变量必须拥有类型</div><div class="line">rule 2：</div><div class="line">变量必须有名称</div><div class="line"></div><div class="line">变量分为两种： </div><div class="line">primitive 和 引用类型</div><div class="line">primitive类型：</div></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">`boolean`    true or false</div><div class="line">`char`   16 bits   0 ~ 65535    定义时使用单引号</div><div class="line">`byte`   8 bits  -128-127</div><div class="line">`short`   16 bits -32768-32767</div><div class="line">`int`   32 bits -2147483648-2147483647</div><div class="line">`long`  64 bits </div><div class="line">`float`  32bits</div><div class="line">`double`  64bits</div></pre></td></tr></table></figure></p>
<p>变量命名规则：</p>
<ul>
<li>名称必须以字母、下划线或$开头，不能用数字开头</li>
<li>避开java 的关键字</li>
</ul>
<p>引用类型：</p>
<ul>
<li>没有对象变量这种东西</li>
<li>只有引用到对象的变量</li>
<li>对象引用变量保存的是存取对象的方法</li>
<li>他并不是对象的容器，而是类似指向对象的指针。或者说是地址</li>
</ul>
<p>注意：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Dog dog = new Dog();</div><div class="line">System.out.println(dog);   //Dog@7852e922 显然 dog 的值类似于指针的存储的真正的对象的地址  他本身是个引用</div><div class="line"></div><div class="line">Dog a = null;   //这样是允许的</div><div class="line"></div><div class="line">Dog b = dog；  </div><div class="line">System.out.println(b);   </div><div class="line">//Dog@7852e922   它的值和 dog 本身的值是一样的，因为引用的是同一个对象</div></pre></td></tr></table></figure></p>
<h2>方法</h2>
<p>Java 的方法中的参数是值传递，并不是引用传递</p>
<p>对于简单类型（primitive）主类型数据而言： 形参是对实参的拷贝
对于对象类型而言： 实质上传入的是远程控制的拷贝</p>
<h2>数据隐藏</h2>
<p>要将程序从不良数据改成可以保护数据并且让你还能修改数据的方式是简单的，使用getter 和setter 即可</p>
<p>将实例变量标记为private
将getter和setter 设置为public</p>
<h2>数据初始化</h2>
<p><code>实例变量</code>是存在默认值的，局部变量是没有默认值的</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">integers  0</div><div class="line">floating points 0.0</div><div class="line">booleans false</div><div class="line">reference  null</div></pre></td></tr></table></figure></p>
<p>注意： String 的初始化为 null</p>
<h2>变量比较</h2>
<p>primitive 类型的数据使用 == 进行比较</p>
<p>如果是对象比较的话 需要使用equals()方法</p>
<h2>内置对象的使用</h2>
<p>ArrayList</p>
<ul>
<li>add</li>
<li>remove</li>
<li>contains</li>
<li>isEmpty</li>
<li>indexOf</li>
<li>size</li>
<li>get</li>
</ul>
<p>ArrayList  不能存储primitive类型，但是可以存储<code>类类型</code>
注意ArrayList 需要导入</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   import java.util.ArrayList;</div><div class="line">   </div><div class="line">   ArrayList&lt;int&gt; arr = new ArrayList&lt;int&gt;();    //error</div><div class="line">ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();</div></pre></td></tr></table></figure></p>
<h2>java package 包</h2>
<p>在java 的API中，类是被包装在包中的，要使用API中的类，你必须知道它被放在了哪个包中。</p>
<p>除了java.lang 包外，其余的所有的java 包都需要在使用时(import)导入 或者使用全称
如何导入包</p>
<blockquote>
<p>import java.util.ArrayList</p>
</blockquote>
<p>包的意义：</p>
<ul>
<li>帮助组织项目</li>
<li>制造出命名空间，避免类的冲突</li>
<li>限制同一命名空间下的类才能相互存取</li>
</ul>
<p>java 的命名包的传统</p>
<h2>接口</h2>
<p>是一个100%的抽象类,</p>
<p>有些类不应该被初始化，不能被new 出来创造出该类的实例</p>
<p>抽象类是必须被继承的
抽象方法是必须要被覆盖的</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">abstract class Canine extends Animal()&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口的定义：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public interface Pet &#123; ...&#125;</div></pre></td></tr></table></figure></p>
<p>接口的实现：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class Dog extends Canine implements Pet &#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>extend 只能有一个，但是implement 可以有多个</p>
<p>实现某接口的类必须实现它所有的方法</p>
<h2>对象的前世今生</h2>
<blockquote>
<p>对象有生有死</p>
</blockquote>
<h3>java 的堆与栈</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">java中使用了两种内存区域： 堆与栈</div><div class="line">堆：对象的生存空间</div><div class="line">栈：方法调用及变量的生存空间</div><div class="line"></div><div class="line">堆上存储：对象；实例变量；</div><div class="line">当一个新建对象带有对象引用的变量时，会在堆上存储这个引用类型的变量的空间</div><div class="line">栈上存储：局部变量；方法调用；对象的引用；</div></pre></td></tr></table></figure></p>
<h3>构造函数</h3>
<p>构造函数的要求：</p>
<ul>
<li>没有返回值</li>
<li>名称与类名一致</li>
<li>如果你自己写了一个传参的构造函数，那么无参的构造函数也必须自己写</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Car&#123;</div><div class="line">    public Car()&#123;</div><div class="line">      //构造函数</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数不会被继承</p>
<p>构造函数链
如果新建（new）一个继承的类的对象时，父类的构造函数是被依次执行的</p>
<p>实践：如果要在构造对象时传入参数，那么最好写两个构造函数以适应传参和不传参两种情况</p>
<p>如何调用父类的构造函数 <code>super()</code>，当然如果没写，编译器会帮我们自动加上的
<strong>this</strong>可以使用this()来从某个构造函数调用同一个类的另外一个构造函数；
this()只能用在构造函数中，且必须在第一行语句中。
super和this不能兼得</p>
<h2>静态方法和非静态方法</h2>
<p>方法名前加入static关键字，申明这个方法的调用不需要实例对象
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">静态的方法不能调用非静态的变量</div><div class="line">静态的方法也不能调用非静态的方法</div></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">非静态的方法可以调用静态的变量</div><div class="line">非静态的方法可以调用静态的方法</div></pre></td></tr></table></figure></p>
<h2>静态变量</h2>
<p>静态变量被所有的实例对象所共享</p>
<h2>final</h2>
<p>静态的final变量是常数，初始化后不能被改变
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final double PI = 3.1415926;</div></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final 的变量代表你不能改变它的值；</div><div class="line">final 的方法代表你不能覆盖掉该方法；</div><div class="line">final 的类代表你不能继承该类；</div></pre></td></tr></table></figure></p>
<h2>AutoBoxing</h2>
<p>每一个primitive主类型数据都有一个包装用的类
类名为：</p>
<ul>
<li>Boolean</li>
<li>Character</li>
<li>Byte</li>
<li>Short</li>
<li>Integer</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
</ul>
<p>包装与分开包装</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//包装</div><div class="line">int i = 128;</div><div class="line">Interer iWrap = new Interger(i);</div><div class="line">//分开包装</div><div class="line">int unWrapped = iWrap.intValue()；</div></pre></td></tr></table></figure></p>
<h2>Intellij IDEA的快捷键</h2>
<ul>
<li>option  + Enter  快速导包</li>
</ul>
<h2>经验</h2>
<p>1.如何防止一个类被初始化？</p>
<ul>
<li>设置该类为抽象类</li>
<li>或设置该类的构造函数为私有</li>
</ul>
<p>2.类型转换
String 转换为 primitive类型 ：</p>
<blockquote>
<p>Integer.parseInt(&quot;4536.4864&quot;)
Double.parseDouble(&quot;420.20&quot;)</p>
</blockquote>
<p>primitive转换为String类型</p>
<blockquote>
<p>X.toString()</p>
</blockquote>
<p>3.数字的格式化</p>
<p>使用String 的format方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String s = String.format(&quot;%,f&quot;, 10000000.124);</div><div class="line">常用的：</div><div class="line">%d</div><div class="line">%f  %.2f  %,.2f</div><div class="line">%x</div><div class="line">%c</div></pre></td></tr></table></figure></p>
<p>4.日期格式化
使用String 的format方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String.format(&quot;xx&quot;,new Date());</div><div class="line">xx 常用的：</div><div class="line">%tc 完整的日期与时间：   Sun Nov 28 14:52:41 MST 2016</div><div class="line">%tr 只有时间 03：01：47 PM</div><div class="line">%tA， %tB %td  周、月、日  Sunday，november 28</div></pre></td></tr></table></figure></p>
<p>5.如何处理时间
在java中处理时间使用的是继承过的Calendar 的对象
eg：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Calendar cal  = new Calendar();     //error   因为Calendar是一个抽象类</div><div class="line">Calendar cal  = Calendar.getInstance();</div></pre></td></tr></table></figure></p>
<h2>常识</h2>
<p>1.构造函数不能被标记为是静态的
2.构造函数是在静态变量的初始化之后进行的</p>
<h2>Temp</h2>
<p>java的简写：</p>
<p>sout   -&gt; System.out.print()</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建个人博客（一）]]></title>
      <url>http://yoursite.com/2016/08/18/how-to-create-blog-1/</url>
      <content type="html"><![CDATA[<h1>搭建个人博客（一）</h1>
<p><strong>前言</strong></p>
<p>作为一个程序员，平时有一些好的想法，或者笔记想要记录；虽然有很多不错的网站，比如博客园，CSDN······· 但作为一个支持开源的用户，和一个技术控，怎能没有一个自己的博客呢？幸运的是，因为公司要求写一篇Markdown语法的博客，就想着索性自己搭一个博客吧。so，利用这两天的时间，在网上看了很多的教程，又在自己的不断摸索下，终于尝试成功了，搭建了一个github + hexo + 自己域名 + Next 主题 的一个博客</p>
<p>地址：</p>
<blockquote>
<p>Alvin-blog <a href="http://sialvsic.com" target="_blank" rel="external">http://sialvsic.com</a></p>
</blockquote>
<p><strong>感想</strong></p>
<p>想想发现，确实有很多的博客写的不错，但是因为时间的缘故，技术的更新和网址的变更带来很多的问题，而且博文的水平参差不齐，我看的第一篇文章就是带有错误的文章，很可能一个小小的命令的错误就会带给读者很大的困惑，感觉博主也应该对此负责，时常的更新或者有一些提醒；综上，想分享一下我的过程，希望能够给读者带来一些帮助。</p>
<p><strong>声明</strong></p>
<p>本文适合</p>
<ul>
<li>linux和mac的用户，对windows的用户有一定的参考价值</li>
<li>有一定基础的人员参考，对于0基础人员权当是学习一下</li>
</ul>
<p><strong>前提</strong></p>
<ul>
<li>git</li>
<li>github 特别是gh-pages</li>
<li>markdown</li>
</ul>
<p><strong>START</strong></p>
<p>我会分阶段逐步完成整个过程，希望大家可以边看边完成</p>
<p><strong>ToDoList</strong></p>
<ul>
<li><strong>安装npm</strong></li>
<li><strong>利用hexo搭建本地博客</strong></li>
<li><strong>在GitHub上发布博客</strong></li>
<li><strong>购买域名</strong></li>
<li><strong>用自己的域名关联博客</strong></li>
<li><strong>优化hexo博客</strong></li>
</ul>
<hr>
<h2>知识简介</h2>
<h3>GitHub简介</h3>
<blockquote>
<p><strong>GitHub</strong> is a Web-based Git repository hosting service。    —— <a href="https://github.com/" target="_blank" rel="external">GitHub</a></p>
</blockquote>
<p>即：GitHub就是一个基于Web的托管服务，当然GitHub的功能不单单有这些。</p>
<h3>GitHub Pages 简介</h3>
<blockquote>
<p><strong>GitHub Pages</strong> 本用于介绍托管在 GitHub 的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。    — <a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a></p>
</blockquote>
<p>GitHub Pages可以被认为是用户编写的、托管在github上的静态网页。</p>
<p><img src="http://obqvt6b56.bkt.clouddn.com/blog-githubPages.jpg" alt="Alt text"></p>
<h3>Hexo简介</h3>
<blockquote>
<p>快速、简洁且高效的博客框架    —— <a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a></p>
</blockquote>
<p><img src="http://obqvt6b56.bkt.clouddn.com/hexo.png" alt="Alt text"></p>
<h2>安装必备软件</h2>
<p>可以参考 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a> 安装下列两个软件</p>
<h3>1.安装Npm</h3>
<blockquote>
<p>npm — a package manager for javascript：node 的包管理器</p>
</blockquote>
<p>github:  https://github.com/npm/npm</p>
<p>官网：https://www.npmjs.com/</p>
<p>对于Linux和Mac 的用户直接点开上面的github的地址，执行<code>Fancy Install (Unix)</code>中的命令即可</p>
<p>实质上安装完node.js后会带有npm，所以可以按照官网的方式安装node.js即可</p>
<h3>2.安装<a href="http://git-scm.com/" target="_blank" rel="external">Git</a></h3>
<p>建议使用包管理器来安装
Linux:<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install git</div></pre></td></tr></table></figure></p>
<p>Mac：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install git</div></pre></td></tr></table></figure></p>
<h2>利用hexo搭建本地博客</h2>
<h3>安装hexo</h3>
<p>安装hexo
所有必备的软件安装完成后，即可使用 npm 安装 Hexo
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<h3>本地初始化博客</h3>
<p>1.安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<p>2.初始化完成后，运行如下命令自动生成hexo 博客相关的文件</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure></p>
<p>3.运行如下命令，打开本地的服务器</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure></p>
<p>4.在浏览器中打开localhost:4000，既可看到hexo运行的结果，本地的博客也就搭建完成了</p>
<h3>如何写博客</h3>
<p>使用hexo 写一篇博客是非常简单的，输入以下命令</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new &lt;title&gt;    // hexo new firstarticle</div></pre></td></tr></table></figure></p>
<p>即可看到在<code>source/_posts</code> 文件夹下生成一个<code>&lt;title&gt;</code>命名的md（markdown）文件，用自己的喜欢的编辑器打开这个文件就可以书写博客了</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INFO  Created: ~/xxxx/source/_posts/firstarticle.md</div></pre></td></tr></table></figure></p>
<h3>发布博客</h3>
<p>书写完成后，运行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure></p>
<p>自动生成博客文件，之后运行</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<p>可以在localhost:4000看到自己写的博文</p>
<h2>在github上发布博客</h2>
<h3>建立个人的GitHub的仓库</h3>
<p>1.github注册帐号</p>
<p>2.新建库 可以看到有个<code>绿色</code>的New按钮</p>
<p><img src="http://obqvt6b56.bkt.clouddn.com/blog-github-person.png" alt="Alt text"></p>
<p>点击进入后，在此处填入的库名个是为:  账户名.github.io
比如：我的账户名为sialvsic，那么此处填入的库名为 <code>sialvsic.github.io</code></p>
<p><img src="http://obqvt6b56.bkt.clouddn.com/blog-github-new.png" alt="Alt text"></p>
<p>点击create repository后，即可在github上生成一个git库</p>
<p><em>note</em> ：利用<strong>账户.github.io</strong> 这种方式搭建博客，每个github账户只能创建一个。</p>
<h3>发布到GitHub上</h3>
<p>1.配置xx文件</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line"><span class="built_in">type</span>: git</div><div class="line">repo: &lt;repository url&gt;</div><div class="line">branch: [branch]</div><div class="line">message: [message]</div></pre></td></tr></table></figure></p>
<p>2.此时执行hexo deploy的命令(注意命令行中的行为)，即可将自己刚刚生成的博客发布到github上，可以登录以下url查看</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://账户名.github.io       eg:http://sialvsic.github.io</div></pre></td></tr></table></figure></p>
<p><em>note:</em> 可能deploy之后不会立即看到结果，需要等待10分钟左右。</p>
<p>当然到现在为止，一个免费的博客已经建立了，但唯一的问题就是以这个以下网址访问显得过low，身为博主，当然得有自己的域名，so 下一篇开始详述设置自己的域名</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://xxxx.github.io</div></pre></td></tr></table></figure></p>
<h2>常见问题</h2>
<p>1.一开始以为要像平时使用github，要将所有的文件要放在 github 的库中</p>
<p><strong>对于sialvsic.github.io/库名</strong> 此类项目
文件的内容push到gh-pages分支，要呈现的页面以index.html为开始页面，github的会自动识别</p>
<p><strong>对于sialvsic.github.io</strong> 这种，github官方的文档说内容要push在master分支中，我最初不清楚<strong>hexo的工作原理</strong>，将整个hexo的文件夹push到sialvsic.github.io库中的master分支上，但是发现并不起作用，最后我才明白，原来根本不需要自己push到库中，在执行hexo deploy命令时，hexo会自动生成的html + css这些东西push到库中，而这个映射关系就是自己在_config.yml文件中写的这个配置</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy：</div><div class="line"><span class="built_in">type</span>：</div><div class="line">repo：&lt;repository url&gt;</div><div class="line">branch：[branch]</div><div class="line">message：[message]</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Communication and some idea]]></title>
      <url>http://yoursite.com/2015/11/27/communication-and-some-idea/</url>
      <content type="html"><![CDATA[<h1>沟通 &amp;&amp; 一些感想</h1>
<p><strong>前言</strong></p>
<p>本周的思沃大讲堂，讲师和我们分享了有关沟通的一些方法，原则和实践，感觉收获良多。也不由得引起自己的一些思考：</p>
<h2>关于沟通</h2>
<p>一直以来自己是一个偏于内向的人，我是哥哥，而双胞胎的弟弟更加外向一些，或许就是这么互补吧。小时候父亲总说希望我能够外向些，能够像弟弟一样，多和别人沟通，交流。但一直以来，听过了早已无数次，但一直没有在意，到了大学，也是如此。或许我觉得一个人的生活更有意思，但实际上我心里的答案并不是这样，我觉得更大程度上是因为没有处在一个自己期待中的环境吧，没有遇到志同道合的朋友。可是，这样的想法对么，这是一个借口或是理由么，当然不是。现在想想，之前的我活的太局限了，以为自己看到的就是世界的全部，呆在自己的世界飘飘然。然而，自从暑假，进入思沃学院，这短短的一个半月时间，给我带来了巨大的成长，我不再是一个以自我为中心的弱者，老师给我们带来的是一种启示和引导，思想上到蜕变和做事方法的改变是让我觉得收获最大的。让我明白了，原来世界真的很大，我所不知道的东西还有很多，自己之前的想法还是太天真了。</p>
<p>就如我们的本周做的feedback一样，暑假我们也相互做了feedback，well的方面就不多说了，less well方面大家都觉得我可能还是平日里交流沟通太少，不怎么说话，有些沉默寡言······
我觉得大家说的很对，这确实是一个很大的问题，当时我就意识到，既然大家给我提出了这个问题那么这个问题就必须去解决。so，我对自己说，希望今后多和大家交流，哪怕每天只是多说一句话，多问一个问题。 如今，回过头来看看，这段时间里，自己确实有着很大变化，如果不是大家的反馈，我可能也没有这种良性的变化。</p>
<p>周六的时候，讲师更多的是去讲一些，在一个团队中如何去沟通的问题，毕竟沟通是解决问题的一种很良好的方式。对一个敏捷的团队也是如此，我知道thoughtworks是一家推行敏捷的公司，我们的项目团队也基本采用敏捷的模式，归纳而言，沟通在一个团队中最大的好处就是做了两件事：</p>
<blockquote>
<p>如果你想要，就一定要说，不说，别人怎么知道你想要呢？ （敢于沟通)</p>
<p>要想尽一切办法， 让客户觉得：“你以为你以为的就是你以为的” （确认自己的想法)</p>
</blockquote>
<p><code>客户付钱是让我们把事情做对而不是把事情改对</code>,及时的沟通会让我们减少很多不必要的事情。</p>
<p>虽然我没有亲身经历过一个真实的项目，可我也明白，有时候你不问清楚，有一点点的模糊都会带来很多的错误，甚至灾难。因为在一定程度上，每个都会发自本能的去脑补了一些不太清晰的东西，以我们自身的角度去理解，去判断。 这是很危险的。</p>
<p><strong>总结</strong></p>
<p>说了很多，其实道理大家都懂，就看自身怎么去实践，不懂就要问，这是小学时我们都学过的道理，只要我们在加上合适的时机和方式，沟通也没有那么难。</p>
<hr>
<h2>关于思沃大讲堂</h2>
<p>感觉过的很快，六周已经过去了，回顾这六周的内容：</p>
<ul>
<li>linux</li>
<li>git</li>
<li>html + css</li>
<li>response-design</li>
<li>javascript</li>
<li>communication</li>
</ul>
<p>每一周讲师都会给我们带来新鲜的技术和内容，让我在这六周里有很快的成长，接触到很多新鲜的事物，也逐渐认清了自己，知道了自己的水平如何，路还很长，还要学习很多的东西，但是看大家都很努力的拼搏成长，我也不能落后。</p>
<p>上周六的测试着实给人一次打击，简单的3道练习竟然没能按时做出来，当天晚上回去查了些资料才做出来了。回过头来想想，这是有问题的，我应该可以做出来而未能按时做出来，我觉得一方面是因为最近没有练习js 的编程，给自己提了个醒，重要的还是<code>基础</code>，<code>基础</code>，<code>基础</code> ，自己在API这方面还要再下功夫，多看，多学，多练；还有一方面是因为自己的时间安排不合理，效率有些低，经常陷入yak shaving的困境，浪费了很多的时间。最近的琐事比较多，没有办法很好的集中精力去做事情，这事目前亟待解决的。</p>
<p>解决方法：</p>
<ol>
<li>坚持使用种子习惯，坚持培养良好的习惯</li>
<li>使用一些效率工具 todoist， toggle，trello</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
